// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %clang_cc1 -triple riscv64 -target-feature +experimental-matrix -target-feature +experimental-v -target-feature +f -target-feature +d -disable-O0-optnone -emit-llvm %s -o - | opt -S -mem2reg | FileCheck --check-prefix=CHECK-IR-RV64 %s


#include <riscv_matrix.h>

// CHECK-IR-RV64-LABEL: @test_mfmv_a_f_mfloat16_m1(
// CHECK-IR-RV64-NEXT:  entry:
// CHECK-IR-RV64-NEXT:    [[TMP0:%.*]] = bitcast half* [[IN1:%.*]] to <vscale x 64 x half>*
// CHECK-IR-RV64-NEXT:    [[TMP1:%.*]] = call <vscale x 64 x half> @llvm.riscv.mlc.m.nxv64f16.i64(<vscale x 64 x half>* [[TMP0]], i64 [[A:%.*]]) #[[ATTR4:[0-9]+]]
// CHECK-IR-RV64-NEXT:    [[TMP2:%.*]] = call <vscale x 64 x half> @llvm.riscv.mfmv.a.f.nxv64f16.f16.i64(<vscale x 64 x half> [[TMP1]], half 0xH4500, i64 [[A]]) #[[ATTR4]]
// CHECK-IR-RV64-NEXT:    [[TMP3:%.*]] = bitcast half* [[OUT:%.*]] to <vscale x 64 x half>*
// CHECK-IR-RV64-NEXT:    call void @llvm.riscv.msc.m.nxv64f16.i64(<vscale x 64 x half> [[TMP2]], <vscale x 64 x half>* [[TMP3]], i64 [[A]]) #[[ATTR4]]
// CHECK-IR-RV64-NEXT:    ret void
//
void test_mfmv_a_f_mfloat16_m1(const _Float16 *in1, _Float16 *out, size_t a) {
    mfloat16_t m1 = mlc_m(in1, a);
    m1 = mfmv_a_f(m1, 5.0, a);
    msc_m(m1, out, a);
    return;
}

// CHECK-IR-RV64-LABEL: @test_mfmv_a_f_mfloat32_m1(
// CHECK-IR-RV64-NEXT:  entry:
// CHECK-IR-RV64-NEXT:    [[TMP0:%.*]] = bitcast float* [[IN1:%.*]] to <vscale x 32 x float>*
// CHECK-IR-RV64-NEXT:    [[TMP1:%.*]] = call <vscale x 32 x float> @llvm.riscv.mlc.m.nxv32f32.i64(<vscale x 32 x float>* [[TMP0]], i64 [[A:%.*]]) #[[ATTR4]]
// CHECK-IR-RV64-NEXT:    [[TMP2:%.*]] = call <vscale x 32 x float> @llvm.riscv.mfmv.a.f.nxv32f32.f32.i64(<vscale x 32 x float> [[TMP1]], float 5.000000e+00, i64 [[A]]) #[[ATTR4]]
// CHECK-IR-RV64-NEXT:    [[TMP3:%.*]] = bitcast float* [[OUT:%.*]] to <vscale x 32 x float>*
// CHECK-IR-RV64-NEXT:    call void @llvm.riscv.msc.m.nxv32f32.i64(<vscale x 32 x float> [[TMP2]], <vscale x 32 x float>* [[TMP3]], i64 [[A]]) #[[ATTR4]]
// CHECK-IR-RV64-NEXT:    ret void
//
void test_mfmv_a_f_mfloat32_m1(const float *in1, float *out, size_t a) {
    mfloat32_t m1 = mlc_m(in1, a);
    m1 = mfmv_a_f(m1, 5.0, a);
    msc_m(m1, out, a);
    return;
}

// CHECK-IR-RV64-LABEL: @test_mfmv_a_f_mfloat64_m1(
// CHECK-IR-RV64-NEXT:  entry:
// CHECK-IR-RV64-NEXT:    [[TMP0:%.*]] = bitcast double* [[IN1:%.*]] to <vscale x 16 x double>*
// CHECK-IR-RV64-NEXT:    [[TMP1:%.*]] = call <vscale x 16 x double> @llvm.riscv.mlc.m.nxv16f64.i64(<vscale x 16 x double>* [[TMP0]], i64 [[A:%.*]]) #[[ATTR4]]
// CHECK-IR-RV64-NEXT:    [[TMP2:%.*]] = call <vscale x 16 x double> @llvm.riscv.mfmv.a.f.nxv16f64.f64.i64(<vscale x 16 x double> [[TMP1]], double 5.000000e+00, i64 [[A]]) #[[ATTR4]]
// CHECK-IR-RV64-NEXT:    [[TMP3:%.*]] = bitcast double* [[OUT:%.*]] to <vscale x 16 x double>*
// CHECK-IR-RV64-NEXT:    call void @llvm.riscv.msc.m.nxv16f64.i64(<vscale x 16 x double> [[TMP2]], <vscale x 16 x double>* [[TMP3]], i64 [[A]]) #[[ATTR4]]
// CHECK-IR-RV64-NEXT:    ret void
//
void test_mfmv_a_f_mfloat64_m1(const double *in1, double *out, size_t a) {
    mfloat64_t m1 = mlc_m(in1, a);
    m1 = mfmv_a_f(m1, 5.0, a);
    msc_m(m1, out, a);
    return;
}

// CHECK-IR-RV64-LABEL: @test_mfmv_f_a_mfloat16_m1(
// CHECK-IR-RV64-NEXT:  entry:
// CHECK-IR-RV64-NEXT:    [[TMP0:%.*]] = bitcast half* [[IN1:%.*]] to <vscale x 64 x half>*
// CHECK-IR-RV64-NEXT:    [[TMP1:%.*]] = call <vscale x 64 x half> @llvm.riscv.mlc.m.nxv64f16.i64(<vscale x 64 x half>* [[TMP0]], i64 [[A:%.*]]) #[[ATTR4]]
// CHECK-IR-RV64-NEXT:    [[TMP2:%.*]] = call half @llvm.riscv.mfmv.f.a.f16.nxv64f16.i64(<vscale x 64 x half> [[TMP1]], i64 [[A]]) #[[ATTR4]]
// CHECK-IR-RV64-NEXT:    ret half [[TMP2]]
//
_Float16 test_mfmv_f_a_mfloat16_m1(const _Float16 *in1, size_t a) {
    mfloat16_t m1 = mlc_m(in1, a);
    return mfmv_f_a(m1, a);
}

// CHECK-IR-RV64-LABEL: @test_mfmv_f_a_mfloat32_m1(
// CHECK-IR-RV64-NEXT:  entry:
// CHECK-IR-RV64-NEXT:    [[TMP0:%.*]] = bitcast float* [[IN1:%.*]] to <vscale x 32 x float>*
// CHECK-IR-RV64-NEXT:    [[TMP1:%.*]] = call <vscale x 32 x float> @llvm.riscv.mlc.m.nxv32f32.i64(<vscale x 32 x float>* [[TMP0]], i64 [[A:%.*]]) #[[ATTR4]]
// CHECK-IR-RV64-NEXT:    [[TMP2:%.*]] = call float @llvm.riscv.mfmv.f.a.f32.nxv32f32.i64(<vscale x 32 x float> [[TMP1]], i64 [[A]]) #[[ATTR4]]
// CHECK-IR-RV64-NEXT:    ret float [[TMP2]]
//
float test_mfmv_f_a_mfloat32_m1(const float *in1, size_t a) {
    mfloat32_t m1 = mlc_m(in1, a);
    return mfmv_f_a(m1, a);
}

// CHECK-IR-RV64-LABEL: @test_mfmv_f_a_mfloat64_m1(
// CHECK-IR-RV64-NEXT:  entry:
// CHECK-IR-RV64-NEXT:    [[TMP0:%.*]] = bitcast double* [[IN1:%.*]] to <vscale x 16 x double>*
// CHECK-IR-RV64-NEXT:    [[TMP1:%.*]] = call <vscale x 16 x double> @llvm.riscv.mlc.m.nxv16f64.i64(<vscale x 16 x double>* [[TMP0]], i64 [[A:%.*]]) #[[ATTR4]]
// CHECK-IR-RV64-NEXT:    [[TMP2:%.*]] = call double @llvm.riscv.mfmv.f.a.f64.nxv16f64.i64(<vscale x 16 x double> [[TMP1]], i64 [[A]]) #[[ATTR4]]
// CHECK-IR-RV64-NEXT:    ret double [[TMP2]]
//
double test_mfmv_f_a_mfloat64_m1(const double *in1, size_t a) {
    mfloat64_t m1 = mlc_m(in1, a);
    return mfmv_f_a(m1, a);
}
